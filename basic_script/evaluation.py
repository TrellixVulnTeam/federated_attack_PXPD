from __future__ import print_function
import os, sys
sys.path.append(os.path.abspath('../'))
import numpy as np
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE
from matplotlib import pyplot as plt

import torch
import torch.nn as nn
import torch.optim as optim
import torch.nn.functional as F
import torch.backends.cudnn as cudnn

import torchvision
import torchvision.transforms as transforms

import argparse

def federadate_attack_robustness_comprison(original_image_batch,
                                           original_class_batch,
                                           local_adv_image_batch_list,
                                           federated_adv_image_batch,
                                           local_model_list,
                                           test_model_list=[],
                                           adv_name_list=None,
                                           save_file_name="robustness.jpg"
                                          ):
    '''
    Description: Given a set of images (e.g., S0) to attack, and the adversarial 
    images (e.g., [S1, S2, S3]) generated by local attackers on each of the local
    models (e.g., [M1, M2, M3] respectively), and the adversarial images (e.g, S4) 
    generated by the federated attacker, and the outside models (e.g., [M4, M5]) 
    that no attackers have accessed, this function computes the attack success 
    rate of each of the local adversial images (e.g., [S1, S2, S3]) averaged over 
    local models (e.g., [M1, M2, M3]) and attack success rate of each of the local 
    adversial images average over outside models (e.g., [M4, M5]), and then 
    compares those with the counterparts of the federatedly generated adversial 
    images. These rates are subject to the images, of which the original images 
    are correctly predicted by all models (e.g., [M1, M2, M3, M4, M5]). 
    
    Input:
    original_image_batch: the set of images to attack, in the format of an input 
                batch directly feeded into a nn, e.g., S0.
    original_class_batch: the true class of the images, in the format of an output
                batch used in the loss function of a nn.
    local_adv_image_batch_list: a list of local adversirial images, e.g., 
                [S1, S2, S3], each element is an image batch created by a local 
                attacker.
    federated_adv_image_batch: the adversarial image batch created by the federated 
                attacker, e.g., S4,
    local_model_list: a list of local nn, e.g., [M1, M2, M3], each of which trains
                a local adversirial image batch.
    test_model_list: a list of test nn, e.g., [M4, M5], which the attackers have 
                never seen.
    adv_name_list: the name list of local adversarial image batch, used to creat a 
                comparison figure.
    save_file_name: the file name to store the comparison figure.
    
    Output:
    attack_success_rate_on_local_models: a list of the attack success rate averaged
                over local models. The rate of the federated attacker lists at last.
    attack_success_rate_on_test_models: a list of the attack success rate averaged
                over test models. The rate of the federated attacker lists at last.
    A comparison figure saved in "../results/filename". 
    '''
    
    batch_len = len(original_image_batch)
    
    n_local_models = len(local_model_list)
    n_test_models = len(test_model_list)
    n_local_advs = len(local_model_list)
    if n_test_models!=n_local_advs:
        print("Error: # of local advs != # of local models!")
        return
    
    local_model_indice = np.arange(n_local_models)
    test_model_indice = np.arange(n_local_models, n_test_models)
    
    all_models = local_model_list + test_model_list
    n_all_models = n_local_models + n_test_models
    
    prediction_on_original_images = np.zeros((n_all_models, batch_len))
    for i, model in enumerate(all_models):
        model.eval()
        output = model(original_image_batch)
        prediction_on_original_images[i] = output.max(dim=1, keepdim=True)[1].squeeze().numpy()
    
    origanl_images_corrected_predicted_by_all = (np.sum(prediction_on_original_images
                                                       ==(original_class_batch.numpy()[None,:]), axis=0)
                                                 ==n_all_models)
    #print(origanl_images_corrected_predicted_by_all)
    n_total_attacks = np.sum(origanl_images_corrected_predicted_by_all)
    
    all_adv_image_batch_list = local_adv_image_batch_list + [federated_adv_image_batch]
    prediction_on_adv_images = np.zeros((n_local_advs+1, n_all_models, batch_len))
    for i, adv_images in enumerate(all_adv_image_batch_list):
        for j, model in enumerate(all_models):
            output = model(adv_images)
            prediction_on_adv_images[i, j] = output.max(dim=1, keepdim=True)[1].squeeze().numpy()
    
    prediction_on_adv_images = prediction_on_adv_images[:, :, origanl_images_corrected_predicted_by_all]
    prediction_on_adv_images = prediction_on_adv_images.astype(np.int)
    original_adv_images_classes = original_class_batch.numpy()[origanl_images_corrected_predicted_by_all]
    original_adv_images_classes = original_adv_images_classes.astype(np.int)
    #print(original_adv_images_classes)
    #print(prediction_on_adv_images[0,:,:])
    
    attack_success_indicator = prediction_on_adv_images != (original_adv_images_classes[None, None, :])
    #print(attack_success_indicator[0,:,:])
    
    attack_success_rate = np.sum(attack_success_indicator, axis=-1)/n_total_attacks
    #print(attack_success_rate)
    
    attack_success_rate_on_local_models = np.mean(attack_success_rate[:, :n_local_models], axis=-1)
    attack_success_rate_on_test_models = np.mean(attack_success_rate[:, n_local_models:], axis=-1)
    
    #print(attack_success_rate_on_local_models)
    #print(attack_success_rate_on_test_models)
    
    step = 1
    x_axis = np.arange(n_local_advs+1, step=step)
    width = 0.3 * step
    if adv_name_list is None:
        tick_labels = ['local_adv'+str(i) for i in range(n_local_advs)]
        tick_labels.append('fed_adv')
    else: tick_labels = adv_name_list
    plt.figure()
    plt.bar(x_axis-2*width, height=attack_success_rate_on_local_models, width=width,
            label = "on local models", tick_label=tick_labels)
    plt.bar(x_axis-width, height=attack_success_rate_on_test_models, width=width,
            label = "on test models")
    plt.legend()
    plt.ylabel("Attack success rate ")
    plt.show()
    if not os.path.exists('../results'):
        os.makedirs('../results')
    plt.savefig('../results/'+save_file_name)
    plt.close('all')
    
    return attack_success_rate_on_local_models, attack_success_rate_on_local_models



# main code
if __name__ == "__main__":
    # Prepare test-case data for debugging 
    print('==> Preparing data..')
    transform_train = transforms.Compose([
        transforms.RandomCrop(32, padding=4),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),
    ])

    transform_test = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.4914, 0.4822, 0.4465), (0.2023, 0.1994, 0.2010)),
    ])

    trainset = torchvision.datasets.CIFAR10(root='../data', train=True, download=True, transform=transform_train)
    trainloader = torch.utils.data.DataLoader(trainset, batch_size=128, shuffle=True, num_workers=2)

    testset = torchvision.datasets.CIFAR10(root='../data', train=False, download=True, transform=transform_test)
    testloader = torch.utils.data.DataLoader(testset, batch_size=100, shuffle=False, num_workers=2)

    device = 'cuda' if torch.cuda.is_available() else 'cpu'
    print("device: ", device)

    for batch_idx, (inputs, targets) in enumerate(trainloader):
        #print(batch_idx, inputs.shape, targets.shape )
        inputs, targets = inputs.to(device), targets.to(device)
        break
    
    train_inputs = inputs
    
    test_inputs_list = []
    test_target_list = []
    for batch_idx, (inputs, targets) in enumerate(testloader):
        #print(batch_idx, inputs.shape, targets.shape )
        inputs, targets = inputs.to(device), targets.to(device)
        test_inputs_list.append(inputs)
        test_target_list.append(targets)
        if batch_idx==2: break
            
    # Prepare the models
    from model.imagenet import *
    
    print('==> Building model..')

    net1 = resnet34(pretrained=True)
    model_name = net1.__class__.__name__
    net1 = net1.to(device)
    print('model: ', model_name)

    net2 = resnet50(pretrained=True)
    model_name = net2.__class__.__name__
    net2 = net2.to(device)
    print('model: ', model_name)

    net3 = resnet18(pretrained=True)
    model_name = net3.__class__.__name__
    net3 = net3.to(device)
    print('model: ', model_name)
    
    net4 = resnet18(pretrained=True)
    model_name = net4.__class__.__name__
    net4 = net4.to(device)
    print('model: ', model_name)

    net1.eval()
    output = net1(train_inputs)
    train_targets = output.max(dim=1, keepdim=True)[1].squeeze()
    #print(train_targets)
    
    # Call the function to be debugged
    local_adv1_inputs = torch.cat((train_inputs[:80], test_inputs_list[0][:20]), dim=0)
    local_adv2_inputs = torch.cat((train_inputs[:50], test_inputs_list[0][:50]), dim=0)
    local_fed_adv_inputs = torch.cat((train_inputs[:20], test_inputs_list[0][:80]), dim=0)
    federadate_attack_robustness_comprison(train_inputs[:100], train_targets[:100],
                                           [local_adv1_inputs, local_adv2_inputs],
                                           local_fed_adv_inputs,
                                           [net1, net2],
                                           [net3, net4],
                                           adv_name_list = ['local_adv1', 'local_adv2', 'fed_adv'],
                                           save_file_name="robustness.jpg"
                                          )